//本人不才，望高手看了别见笑。
//     最近在看北科第二届，第三届，第四届的时候，有惊奇的发现。
//        我来说说我的理解。
//    当我们忙着如何处理S的时候，最简单的方法貌似就是穷举发了，所谓的穷举法就是将各种可能性都总结出来，知道找到自己想要的结果。其实有的时候我们跑S也是一个道理。讲过大量的数理统计也一样可以解决穿S的问题。
//   如果你有北科的技术报告你现在可以打开看看，现在看北科的第三届技术报告的第31页下面和第32页上面
//for(n = (MAX_VIDEO_USEDLINE - 1); n >= 0; n --)
//{
//  if(g_BlackPositionCenter[n] != 250)
//  {
//      if(0 == g_ValidLine)
//      {
//        g_DirectionControl = 0;
//      }
//        g_ValidLine ++;
//        g_BlackLineTotal += g_BlackPositionCenter[n];
//        //============加权平均===================
//        g_center = g_SolutedBlackPositionCenter[n];
//        //g_center = g_BlackPositionCenter[n];
//        32
//        g_DirectionControlLine += g_coeff[n];
//        g_DirectionControl += g_coeff[n] * g_center;
//  }
////======= ========
//  if(n == 30)
//  {
//    if(g_ValidLine >= 10)
//    {
//      g_BottomMiddle = g_BlackLineTotal / g_ValidLine;
//    }
//  }
//} 
//有这样一段程序大家注意一下。
//    for(i = 0; i < MAX_VIDEO_USEDLINE; i++)
//       {
//        g_coeff = (MAX_VIDEO_USEDLINE - i) * (MAX_VIDEO_USEDLINE - i) * (MAX_VIDEO_USEDLINE - i);
//      // g_coeff = (MAX_VIDEO_USEDLINE - i) * (MAX_VIDEO_USEDLINE - i);
//       } 
//还有有这样一段程序大家注意一下。
//我说的有点复杂，有时间的可以好好分析一下这部分程序
//如果没有时间，看看这样一个表格
//
//n	n*n	n*n*n	n*n*n*n	x	nx	n*n*x	n*n*n*x	n*n*n*n*x	X2-X1	X3-X2	(X2-X1)-(X3-X2)
//1	1	1	1	65	65	65	65	65			
//2	4	8	16	63	126	252	504	1008		-2		
//3	9	27	81	61	183	549	1647	4941		-2	-2	0
//4	16	64	256	59	236	944	3776	15104		-2	-2	0
//5	25	125	625	57	285	1425	7125	35625		-2	-2	0
//6	36	216	1296	55	330	1980	11880	71280		-2	-2	0
//7	49	343	2401	53	371	2597	18179	127253		-2	-2	0
//8	64	512	4096	51	408	3264	26112	208896		-2	-2	0
//9	81	729	6561	49	441	3969	35721	321489		-2	-2	0
//10	100	1000	10000	47	470	4700	47000	470000		-2	-2	0
//11	121	1331	14641	45	495	5445	59895	658845		-2	-2	0
//12	144	1728	20736	43	516	6192	74304	891648		-2	-2	0
//13	169	2197	28561	41	533	6929	90077	1171001		-2	-2	0
//14	196	2744	38416	39	546	7644	107016	1498224		-2	-2	0
//15	225	3375	50625	37	555	8325	124875	1873125		-2	-2	0
//16	256	4096	65536	35	560	8960	143360	2293760		-2	-2	0
//17	289	4913	83521	33	561	9537	162129	2756193		-2	-2	0
//18	324	5832	104976	31	558	10044	180792	3254256		-2	-2	0
//19	361	6859	130321	33	627	11913	226347	4300593		 2	 2	0
//20	400	8000	160000	35	700	14000	280000	5600000		 2	 2	0
//结合这个表格你就会发现那段程序的秘密了。
//n:摄像头由近及远是图像的行数。我设的n=50；
//x:是每行的黑线位置。我选择0到140之间变化。
//执行完g_DirectionControlLine += g_coeff[n];
//g_DirectionControl += g_coeff[n] * g_center;
//这段代码后就会发现S弯被滤掉了好多。
//具体的你可以查看一下g_DirectionControl 的值。弯道和直到，还有S的重心就会得到很好的处理
//然后将值给多舵机就可以了
//说的不太清楚。可以给我发邮件讨论